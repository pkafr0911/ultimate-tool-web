{"version":3,"sources":["node_modules/cssbeautify/cssbeautify.js","node_modules/json2mq/index.js","node_modules/@ant-design/pro-layout/node_modules/path-to-regexp/dist/index.js","node_modules/string-convert/camel2hyphen.js"],"sourcesContent":["/*\n Copyright (C) 2013 Sencha Inc.\n Copyright (C) 2012 Sencha Inc.\n Copyright (C) 2011 Sencha Inc.\n\n Author: Ariya Hidayat.\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n*/\n\n/*jslint continue: true, indent: 4 */\n/*global exports:true, module:true, window:true */\n\n(function () {\n\n    'use strict';\n\n    function cssbeautify(style, opt) {\n\n        var options, index = 0, length = style.length, blocks, formatted = '',\n            ch, ch2, str, state, State, depth, quote, comment,\n            openbracesuffix = true,\n            autosemicolon = false,\n            trimRight;\n\n        options = arguments.length > 1 ? opt : {};\n        if (typeof options.indent === 'undefined') {\n            options.indent = '    ';\n        }\n        if (typeof options.openbrace === 'string') {\n            openbracesuffix = (options.openbrace === 'end-of-line');\n        }\n        if (typeof options.autosemicolon === 'boolean') {\n            autosemicolon = options.autosemicolon;\n        }\n\n        function isWhitespace(c) {\n            return (c === ' ') || (c === '\\n') || (c === '\\t') || (c === '\\r') || (c === '\\f');\n        }\n\n        function isQuote(c) {\n            return (c === '\\'') || (c === '\"');\n        }\n\n        // FIXME: handle Unicode characters\n        function isName(c) {\n            return (ch >= 'a' && ch <= 'z') ||\n                (ch >= 'A' && ch <= 'Z') ||\n                (ch >= '0' && ch <= '9') ||\n                '-_*.:#[]'.indexOf(c) >= 0;\n        }\n\n        function appendIndent() {\n            var i;\n            for (i = depth; i > 0; i -= 1) {\n                formatted += options.indent;\n            }\n        }\n\n        function openBlock() {\n            formatted = trimRight(formatted);\n            if (openbracesuffix) {\n                formatted += ' {';\n            } else {\n                formatted += '\\n';\n                appendIndent();\n                formatted += '{';\n            }\n            if (ch2 !== '\\n') {\n                formatted += '\\n';\n            }\n            depth += 1;\n        }\n\n        function closeBlock() {\n            var last;\n            depth -= 1;\n            formatted = trimRight(formatted);\n\n            if (formatted.length > 0 && autosemicolon) {\n                last = formatted.charAt(formatted.length - 1);\n                if (last !== ';' && last !== '{') {\n                    formatted += ';';\n                }\n            }\n\n            formatted += '\\n';\n            appendIndent();\n            formatted += '}';\n            blocks.push(formatted);\n            formatted = '';\n        }\n\n        if (String.prototype.trimRight) {\n            trimRight = function (s) {\n                return s.trimRight();\n            };\n        } else {\n            // old Internet Explorer\n            trimRight = function (s) {\n                return s.replace(/\\s+$/, '');\n            };\n        }\n\n        State = {\n            Start: 0,\n            AtRule: 1,\n            Block: 2,\n            Selector: 3,\n            Ruleset: 4,\n            Property: 5,\n            Separator: 6,\n            Expression: 7,\n            URL: 8\n        };\n\n        depth = 0;\n        state = State.Start;\n        comment = false;\n        blocks = [];\n\n        // We want to deal with LF (\\n) only\n        style = style.replace(/\\r\\n/g, '\\n');\n\n        while (index < length) {\n            ch = style.charAt(index);\n            ch2 = style.charAt(index + 1);\n            index += 1;\n\n            // Inside a string literal?\n            if (isQuote(quote)) {\n                formatted += ch;\n                if (ch === quote) {\n                    quote = null;\n                }\n                if (ch === '\\\\' && ch2 === quote) {\n                    // Don't treat escaped character as the closing quote\n                    formatted += ch2;\n                    index += 1;\n                }\n                continue;\n            }\n\n            // Starting a string literal?\n            if (isQuote(ch)) {\n                formatted += ch;\n                quote = ch;\n                continue;\n            }\n\n            // Comment\n            if (comment) {\n                formatted += ch;\n                if (ch === '*' && ch2 === '/') {\n                    comment = false;\n                    formatted += ch2;\n                    index += 1;\n                }\n                continue;\n            }\n            if (ch === '/' && ch2 === '*') {\n                comment = true;\n                formatted += ch;\n                formatted += ch2;\n                index += 1;\n                continue;\n            }\n\n            if (state === State.Start) {\n\n                if (blocks.length === 0) {\n                    if (isWhitespace(ch) && formatted.length === 0) {\n                        continue;\n                    }\n                }\n\n                // Copy white spaces and control characters\n                if (ch <= ' ' || ch.charCodeAt(0) >= 128) {\n                    state = State.Start;\n                    formatted += ch;\n                    continue;\n                }\n\n                // Selector or at-rule\n                if (isName(ch) || (ch === '@')) {\n\n                    // Clear trailing whitespaces and linefeeds.\n                    str = trimRight(formatted);\n\n                    if (str.length === 0) {\n                        // If we have empty string after removing all the trailing\n                        // spaces, that means we are right after a block.\n                        // Ensure a blank line as the separator.\n                        if (blocks.length > 0) {\n                            formatted = '\\n\\n';\n                        }\n                    } else {\n                        // After finishing a ruleset or directive statement,\n                        // there should be one blank line.\n                        if (str.charAt(str.length - 1) === '}' ||\n                                str.charAt(str.length - 1) === ';') {\n\n                            formatted = str + '\\n\\n';\n                        } else {\n                            // After block comment, keep all the linefeeds but\n                            // start from the first column (remove whitespaces prefix).\n                            while (true) {\n                                ch2 = formatted.charAt(formatted.length - 1);\n                                if (ch2 !== ' ' && ch2.charCodeAt(0) !== 9) {\n                                    break;\n                                }\n                                formatted = formatted.substr(0, formatted.length - 1);\n                            }\n                        }\n                    }\n                    formatted += ch;\n                    state = (ch === '@') ? State.AtRule : State.Selector;\n                    continue;\n                }\n            }\n\n            if (state === State.AtRule) {\n\n                // ';' terminates a statement.\n                if (ch === ';') {\n                    formatted += ch;\n                    state = State.Start;\n                    continue;\n                }\n\n                // '{' starts a block\n                if (ch === '{') {\n                    str = trimRight(formatted);\n                    openBlock();\n                    state = (str === '@font-face') ? State.Ruleset : State.Block;\n                    continue;\n                }\n\n                formatted += ch;\n                continue;\n            }\n\n            if (state === State.Block) {\n\n                // Selector\n                if (isName(ch)) {\n\n                    // Clear trailing whitespaces and linefeeds.\n                    str = trimRight(formatted);\n\n                    if (str.length === 0) {\n                        // If we have empty string after removing all the trailing\n                        // spaces, that means we are right after a block.\n                        // Ensure a blank line as the separator.\n                        if (blocks.length > 0) {\n                            formatted = '\\n\\n';\n                        }\n                    } else {\n                        // Insert blank line if necessary.\n                        if (str.charAt(str.length - 1) === '}') {\n                            formatted = str + '\\n\\n';\n                        } else {\n                            // After block comment, keep all the linefeeds but\n                            // start from the first column (remove whitespaces prefix).\n                            while (true) {\n                                ch2 = formatted.charAt(formatted.length - 1);\n                                if (ch2 !== ' ' && ch2.charCodeAt(0) !== 9) {\n                                    break;\n                                }\n                                formatted = formatted.substr(0, formatted.length - 1);\n                            }\n                        }\n                    }\n\n                    appendIndent();\n                    formatted += ch;\n                    state = State.Selector;\n                    continue;\n                }\n\n                // '}' resets the state.\n                if (ch === '}') {\n                    closeBlock();\n                    state = State.Start;\n                    continue;\n                }\n\n                formatted += ch;\n                continue;\n            }\n\n            if (state === State.Selector) {\n\n                // '{' starts the ruleset.\n                if (ch === '{') {\n                    openBlock();\n                    state = State.Ruleset;\n                    continue;\n                }\n\n                // '}' resets the state.\n                if (ch === '}') {\n                    closeBlock();\n                    state = State.Start;\n                    continue;\n                }\n\n                formatted += ch;\n                continue;\n            }\n\n            if (state === State.Ruleset) {\n\n                // '}' finishes the ruleset.\n                if (ch === '}') {\n                    closeBlock();\n                    state = State.Start;\n                    if (depth > 0) {\n                        state = State.Block;\n                    }\n                    continue;\n                }\n\n                // Make sure there is no blank line or trailing spaces inbetween\n                if (ch === '\\n') {\n                    formatted = trimRight(formatted);\n                    formatted += '\\n';\n                    continue;\n                }\n\n                // property name\n                if (!isWhitespace(ch)) {\n                    formatted = trimRight(formatted);\n                    formatted += '\\n';\n                    appendIndent();\n                    formatted += ch;\n                    state = State.Property;\n                    continue;\n                }\n                formatted += ch;\n                continue;\n            }\n\n            if (state === State.Property) {\n\n                // ':' concludes the property.\n                if (ch === ':') {\n                    formatted = trimRight(formatted);\n                    formatted += ': ';\n                    state = State.Expression;\n                    if (isWhitespace(ch2)) {\n                        state = State.Separator;\n                    }\n                    continue;\n                }\n\n                // '}' finishes the ruleset.\n                if (ch === '}') {\n                    closeBlock();\n                    state = State.Start;\n                    if (depth > 0) {\n                        state = State.Block;\n                    }\n                    continue;\n                }\n\n                formatted += ch;\n                continue;\n            }\n\n            if (state === State.Separator) {\n\n                // Non-whitespace starts the expression.\n                if (!isWhitespace(ch)) {\n                    formatted += ch;\n                    state = State.Expression;\n                    continue;\n                }\n\n                // Anticipate string literal.\n                if (isQuote(ch2)) {\n                    state = State.Expression;\n                }\n\n                continue;\n            }\n\n            if (state === State.Expression) {\n\n                // '}' finishes the ruleset.\n                if (ch === '}') {\n                    closeBlock();\n                    state = State.Start;\n                    if (depth > 0) {\n                        state = State.Block;\n                    }\n                    continue;\n                }\n\n                // ';' completes the declaration.\n                if (ch === ';') {\n                    formatted = trimRight(formatted);\n                    formatted += ';\\n';\n                    state = State.Ruleset;\n                    continue;\n                }\n\n                formatted += ch;\n\n                if (ch === '(') {\n                    if (formatted.charAt(formatted.length - 2) === 'l' &&\n                            formatted.charAt(formatted.length - 3) === 'r' &&\n                            formatted.charAt(formatted.length - 4) === 'u') {\n\n                        // URL starts with '(' and closes with ')'.\n                        state = State.URL;\n                        continue;\n                    }\n                }\n\n                continue;\n            }\n\n            if (state === State.URL) {\n\n\n                // ')' finishes the URL (only if it is not escaped).\n                if (ch === ')' && formatted.charAt(formatted.length - 1 !== '\\\\')) {\n                    formatted += ch;\n                    state = State.Expression;\n                    continue;\n                }\n            }\n\n            // The default action is to copy the character (to prevent\n            // infinite loop).\n            formatted += ch;\n        }\n\n        formatted = blocks.join('') + formatted;\n\n        return formatted;\n    }\n\n    if (typeof exports !== 'undefined') {\n        // Node.js module.\n        module.exports = exports = cssbeautify;\n    } else if (typeof window === 'object') {\n        // Browser loading.\n        window.cssbeautify = cssbeautify;\n    }\n\n}());\n","var camel2hyphen = require('string-convert/camel2hyphen');\n\nvar isDimension = function (feature) {\n  var re = /[height|width]$/;\n  return re.test(feature);\n};\n\nvar obj2mq = function (obj) {\n  var mq = '';\n  var features = Object.keys(obj);\n  features.forEach(function (feature, index) {\n    var value = obj[feature];\n    feature = camel2hyphen(feature);\n    // Add px to dimension features\n    if (isDimension(feature) && typeof value === 'number') {\n      value = value + 'px';\n    }\n    if (value === true) {\n      mq += feature;\n    } else if (value === false) {\n      mq += 'not ' + feature;\n    } else {\n      mq += '(' + feature + ': ' + value + ')';\n    }\n    if (index < features.length-1) {\n      mq += ' and '\n    }\n  });\n  return mq;\n};\n\nvar json2mq = function (query) {\n  var mq = '';\n  if (typeof query === 'string') {\n    return query;\n  }\n  // Handling array of media queries\n  if (query instanceof Array) {\n    query.forEach(function (q, index) {\n      mq += obj2mq(q);\n      if (index < query.length-1) {\n        mq += ', '\n      }\n    });\n    return mq;\n  }\n  // Handling single media query\n  return obj2mq(query);\n};\n\nmodule.exports = json2mq;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TokenData = void 0;\nexports.parse = parse;\nexports.compile = compile;\nexports.match = match;\nexports.pathToRegexp = pathToRegexp;\nexports.stringify = stringify;\nconst DEFAULT_DELIMITER = \"/\";\nconst NOOP_VALUE = (value) => value;\nconst ID_START = /^[$_\\p{ID_Start}]$/u;\nconst ID_CONTINUE = /^[$\\u200c\\u200d\\p{ID_Continue}]$/u;\nconst DEBUG_URL = \"https://git.new/pathToRegexpError\";\nconst SIMPLE_TOKENS = {\n    // Groups.\n    \"{\": \"{\",\n    \"}\": \"}\",\n    // Reserved.\n    \"(\": \"(\",\n    \")\": \")\",\n    \"[\": \"[\",\n    \"]\": \"]\",\n    \"+\": \"+\",\n    \"?\": \"?\",\n    \"!\": \"!\",\n};\n/**\n * Escape text for stringify to path.\n */\nfunction escapeText(str) {\n    return str.replace(/[{}()\\[\\]+?!:*]/g, \"\\\\$&\");\n}\n/**\n * Escape a regular expression string.\n */\nfunction escape(str) {\n    return str.replace(/[.+*?^${}()[\\]|/\\\\]/g, \"\\\\$&\");\n}\n/**\n * Tokenize input string.\n */\nfunction* lexer(str) {\n    const chars = [...str];\n    let i = 0;\n    function name() {\n        let value = \"\";\n        if (ID_START.test(chars[++i])) {\n            value += chars[i];\n            while (ID_CONTINUE.test(chars[++i])) {\n                value += chars[i];\n            }\n        }\n        else if (chars[i] === '\"') {\n            let pos = i;\n            while (i < chars.length) {\n                if (chars[++i] === '\"') {\n                    i++;\n                    pos = 0;\n                    break;\n                }\n                if (chars[i] === \"\\\\\") {\n                    value += chars[++i];\n                }\n                else {\n                    value += chars[i];\n                }\n            }\n            if (pos) {\n                throw new TypeError(`Unterminated quote at ${pos}: ${DEBUG_URL}`);\n            }\n        }\n        if (!value) {\n            throw new TypeError(`Missing parameter name at ${i}: ${DEBUG_URL}`);\n        }\n        return value;\n    }\n    while (i < chars.length) {\n        const value = chars[i];\n        const type = SIMPLE_TOKENS[value];\n        if (type) {\n            yield { type, index: i++, value };\n        }\n        else if (value === \"\\\\\") {\n            yield { type: \"ESCAPED\", index: i++, value: chars[i++] };\n        }\n        else if (value === \":\") {\n            const value = name();\n            yield { type: \"PARAM\", index: i, value };\n        }\n        else if (value === \"*\") {\n            const value = name();\n            yield { type: \"WILDCARD\", index: i, value };\n        }\n        else {\n            yield { type: \"CHAR\", index: i, value: chars[i++] };\n        }\n    }\n    return { type: \"END\", index: i, value: \"\" };\n}\nclass Iter {\n    constructor(tokens) {\n        this.tokens = tokens;\n    }\n    peek() {\n        if (!this._peek) {\n            const next = this.tokens.next();\n            this._peek = next.value;\n        }\n        return this._peek;\n    }\n    tryConsume(type) {\n        const token = this.peek();\n        if (token.type !== type)\n            return;\n        this._peek = undefined; // Reset after consumed.\n        return token.value;\n    }\n    consume(type) {\n        const value = this.tryConsume(type);\n        if (value !== undefined)\n            return value;\n        const { type: nextType, index } = this.peek();\n        throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}: ${DEBUG_URL}`);\n    }\n    text() {\n        let result = \"\";\n        let value;\n        while ((value = this.tryConsume(\"CHAR\") || this.tryConsume(\"ESCAPED\"))) {\n            result += value;\n        }\n        return result;\n    }\n}\n/**\n * Tokenized path instance.\n */\nclass TokenData {\n    constructor(tokens) {\n        this.tokens = tokens;\n    }\n}\nexports.TokenData = TokenData;\n/**\n * Parse a string for the raw tokens.\n */\nfunction parse(str, options = {}) {\n    const { encodePath = NOOP_VALUE } = options;\n    const it = new Iter(lexer(str));\n    function consume(endType) {\n        const tokens = [];\n        while (true) {\n            const path = it.text();\n            if (path)\n                tokens.push({ type: \"text\", value: encodePath(path) });\n            const param = it.tryConsume(\"PARAM\");\n            if (param) {\n                tokens.push({\n                    type: \"param\",\n                    name: param,\n                });\n                continue;\n            }\n            const wildcard = it.tryConsume(\"WILDCARD\");\n            if (wildcard) {\n                tokens.push({\n                    type: \"wildcard\",\n                    name: wildcard,\n                });\n                continue;\n            }\n            const open = it.tryConsume(\"{\");\n            if (open) {\n                tokens.push({\n                    type: \"group\",\n                    tokens: consume(\"}\"),\n                });\n                continue;\n            }\n            it.consume(endType);\n            return tokens;\n        }\n    }\n    const tokens = consume(\"END\");\n    return new TokenData(tokens);\n}\n/**\n * Compile a string to a template function for the path.\n */\nfunction compile(path, options = {}) {\n    const { encode = encodeURIComponent, delimiter = DEFAULT_DELIMITER } = options;\n    const data = path instanceof TokenData ? path : parse(path, options);\n    const fn = tokensToFunction(data.tokens, delimiter, encode);\n    return function path(data = {}) {\n        const [path, ...missing] = fn(data);\n        if (missing.length) {\n            throw new TypeError(`Missing parameters: ${missing.join(\", \")}`);\n        }\n        return path;\n    };\n}\nfunction tokensToFunction(tokens, delimiter, encode) {\n    const encoders = tokens.map((token) => tokenToFunction(token, delimiter, encode));\n    return (data) => {\n        const result = [\"\"];\n        for (const encoder of encoders) {\n            const [value, ...extras] = encoder(data);\n            result[0] += value;\n            result.push(...extras);\n        }\n        return result;\n    };\n}\n/**\n * Convert a single token into a path building function.\n */\nfunction tokenToFunction(token, delimiter, encode) {\n    if (token.type === \"text\")\n        return () => [token.value];\n    if (token.type === \"group\") {\n        const fn = tokensToFunction(token.tokens, delimiter, encode);\n        return (data) => {\n            const [value, ...missing] = fn(data);\n            if (!missing.length)\n                return [value];\n            return [\"\"];\n        };\n    }\n    const encodeValue = encode || NOOP_VALUE;\n    if (token.type === \"wildcard\" && encode !== false) {\n        return (data) => {\n            const value = data[token.name];\n            if (value == null)\n                return [\"\", token.name];\n            if (!Array.isArray(value) || value.length === 0) {\n                throw new TypeError(`Expected \"${token.name}\" to be a non-empty array`);\n            }\n            return [\n                value\n                    .map((value, index) => {\n                    if (typeof value !== \"string\") {\n                        throw new TypeError(`Expected \"${token.name}/${index}\" to be a string`);\n                    }\n                    return encodeValue(value);\n                })\n                    .join(delimiter),\n            ];\n        };\n    }\n    return (data) => {\n        const value = data[token.name];\n        if (value == null)\n            return [\"\", token.name];\n        if (typeof value !== \"string\") {\n            throw new TypeError(`Expected \"${token.name}\" to be a string`);\n        }\n        return [encodeValue(value)];\n    };\n}\n/**\n * Transform a path into a match function.\n */\nfunction match(path, options = {}) {\n    const { decode = decodeURIComponent, delimiter = DEFAULT_DELIMITER } = options;\n    const { regexp, keys } = pathToRegexp(path, options);\n    const decoders = keys.map((key) => {\n        if (decode === false)\n            return NOOP_VALUE;\n        if (key.type === \"param\")\n            return decode;\n        return (value) => value.split(delimiter).map(decode);\n    });\n    return function match(input) {\n        const m = regexp.exec(input);\n        if (!m)\n            return false;\n        const path = m[0];\n        const params = Object.create(null);\n        for (let i = 1; i < m.length; i++) {\n            if (m[i] === undefined)\n                continue;\n            const key = keys[i - 1];\n            const decoder = decoders[i - 1];\n            params[key.name] = decoder(m[i]);\n        }\n        return { path, params };\n    };\n}\nfunction pathToRegexp(path, options = {}) {\n    const { delimiter = DEFAULT_DELIMITER, end = true, sensitive = false, trailing = true, } = options;\n    const keys = [];\n    const sources = [];\n    const flags = sensitive ? \"\" : \"i\";\n    const paths = Array.isArray(path) ? path : [path];\n    const items = paths.map((path) => path instanceof TokenData ? path : parse(path, options));\n    for (const { tokens } of items) {\n        for (const seq of flatten(tokens, 0, [])) {\n            const regexp = sequenceToRegExp(seq, delimiter, keys);\n            sources.push(regexp);\n        }\n    }\n    let pattern = `^(?:${sources.join(\"|\")})`;\n    if (trailing)\n        pattern += `(?:${escape(delimiter)}$)?`;\n    pattern += end ? \"$\" : `(?=${escape(delimiter)}|$)`;\n    const regexp = new RegExp(pattern, flags);\n    return { regexp, keys };\n}\n/**\n * Generate a flat list of sequence tokens from the given tokens.\n */\nfunction* flatten(tokens, index, init) {\n    if (index === tokens.length) {\n        return yield init;\n    }\n    const token = tokens[index];\n    if (token.type === \"group\") {\n        const fork = init.slice();\n        for (const seq of flatten(token.tokens, 0, fork)) {\n            yield* flatten(tokens, index + 1, seq);\n        }\n    }\n    else {\n        init.push(token);\n    }\n    yield* flatten(tokens, index + 1, init);\n}\n/**\n * Transform a flat sequence of tokens into a regular expression.\n */\nfunction sequenceToRegExp(tokens, delimiter, keys) {\n    let result = \"\";\n    let backtrack = \"\";\n    let isSafeSegmentParam = true;\n    for (let i = 0; i < tokens.length; i++) {\n        const token = tokens[i];\n        if (token.type === \"text\") {\n            result += escape(token.value);\n            backtrack += token.value;\n            isSafeSegmentParam || (isSafeSegmentParam = token.value.includes(delimiter));\n            continue;\n        }\n        if (token.type === \"param\" || token.type === \"wildcard\") {\n            if (!isSafeSegmentParam && !backtrack) {\n                throw new TypeError(`Missing text after \"${token.name}\": ${DEBUG_URL}`);\n            }\n            if (token.type === \"param\") {\n                result += `(${negate(delimiter, isSafeSegmentParam ? \"\" : backtrack)}+)`;\n            }\n            else {\n                result += `([\\\\s\\\\S]+)`;\n            }\n            keys.push(token);\n            backtrack = \"\";\n            isSafeSegmentParam = false;\n            continue;\n        }\n    }\n    return result;\n}\nfunction negate(delimiter, backtrack) {\n    if (backtrack.length < 2) {\n        if (delimiter.length < 2)\n            return `[^${escape(delimiter + backtrack)}]`;\n        return `(?:(?!${escape(delimiter)})[^${escape(backtrack)}])`;\n    }\n    if (delimiter.length < 2) {\n        return `(?:(?!${escape(backtrack)})[^${escape(delimiter)}])`;\n    }\n    return `(?:(?!${escape(backtrack)}|${escape(delimiter)})[\\\\s\\\\S])`;\n}\n/**\n * Stringify token data into a path string.\n */\nfunction stringify(data) {\n    return data.tokens\n        .map(function stringifyToken(token, index, tokens) {\n        if (token.type === \"text\")\n            return escapeText(token.value);\n        if (token.type === \"group\") {\n            return `{${token.tokens.map(stringifyToken).join(\"\")}}`;\n        }\n        const isSafe = isNameSafe(token.name) && isNextNameSafe(tokens[index + 1]);\n        const key = isSafe ? token.name : JSON.stringify(token.name);\n        if (token.type === \"param\")\n            return `:${key}`;\n        if (token.type === \"wildcard\")\n            return `*${key}`;\n        throw new TypeError(`Unexpected token: ${token}`);\n    })\n        .join(\"\");\n}\nfunction isNameSafe(name) {\n    const [first, ...rest] = name;\n    if (!ID_START.test(first))\n        return false;\n    return rest.every((char) => ID_CONTINUE.test(char));\n}\nfunction isNextNameSafe(token) {\n    if ((token === null || token === void 0 ? void 0 : token.type) !== \"text\")\n        return true;\n    return !ID_CONTINUE.test(token.value[0]);\n}\n//# sourceMappingURL=index.js.map","var camel2hyphen = function (str) {\n  return str\n          .replace(/[A-Z]/g, function (match) {\n            return '-' + match.toLowerCase();\n          })\n          .toLowerCase();\n};\n\nmodule.exports = camel2hyphen;"],"names":[],"mappings":"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"}